<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Rocket Game ¬∑ Telegram WebApp + Leaderboard</title>
  <!-- Google Fonts - Press Start 2P for pixel font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b0f1a; --card:#101727cc; --txt:#eaf2ff; --muted:#9fb3ce;
      --accent:#ffd54a; --accent2:#58d3ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background: radial-gradient(1200px 800px at 70% -10%, #16213e 0%, #0b0f1a 55%, #090d16 100%);
      color:var(--txt); 
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; /* Default for UI elements */
      overflow:hidden;
    }
    /* Apply pixel font to specific elements if desired, or globally */
    h1, h2, .btn, th, td.score, #gameCanvas + script + script { /* Targeting elements that might use the pixel font */
        font-family: 'Press Start 2P', cursive, monospace;
    }
    /* Adjust font size for pixel font if it looks too small */
    #homeScreen h1 {
        font-size: clamp(20px, 5vw, 36px); /* Slightly smaller for pixel font */
    }
    .btn {
        font-size: clamp(14px, 3.5vw, 16px); /* Slightly smaller for pixel font */
    }
    th {
        font-size: 12px; /* Adjust for pixel font readability */
    }
    td.score {
        font-size: 16px; /* Adjust for pixel font readability */
    }

    /* Top-left user badge */
    #userInfo{
      position: fixed; top: 12px; left: 12px; z-index: 20;
      display:flex; align-items:center; gap:10px;
      padding: 8px 12px; border-radius: 999px;
      background: linear-gradient(180deg, #0f1430aa, #0c1126aa);
      box-shadow: 0 8px 24px #0006, inset 0 0 0 1f;
      backdrop-filter: blur(8px);
    }
    #userPhoto{ width:32px; height:32px; border-radius:50%; object-fit:cover; }
    #userName{ font-weight:600; color:#fff }

    /* Screens */
    .screen{
      position: fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      padding:24px; z-index: 15;
      background: linear-gradient(180deg, #0a0f1ab3, #0a0f1acc);
      backdrop-filter: blur(6px);
    }
    #homeCard{
      width:min(720px, 92vw);
      background: var(--card);
      border-radius: 18px; padding: 22px;
      box-shadow: 0 16px 48px #0009, inset 0 0 0 1f;
      text-align:center;
    }
    .sub{ color:var(--muted); margin: 4px 0 18px; }
    .row{ display:flex; gap:12px; justify-content:center; flex-wrap:wrap; }

    .btn{
      border:0; cursor:pointer;
      background: linear-gradient(180deg, #ffd54a, #ffb300);
      color:#2b1900; font-weight:700; letter-spacing: .3px;
      padding: 12px 18px; border-radius: 12px; 
      box-shadow: 0 8px 20px #ffb30052, inset 0 0 0 1f;
      transition: transform .08s ease, filter .2s ease, box-shadow .2s ease;
    }
    .btn:hover{ filter:brightness(1.05) }
    .btn:active{ transform: translateY(1px) }

    /* Canvas */
    #gameCanvas{ display:block; width:100vw; height:100vh; }

    /* Leaderboard */
    #leaderboardScreen{ display:none }
    #boardCard{
      width:min(860px, 96vw);
      background: var(--card);
      border-radius: 18px; padding: 18px 14px 14px;
      box-shadow: 0 16px 48px #0009, inset 0 0 0 1f;
    }
    table{ width:100%; border-collapse: collapse; }
    th, td{ padding: 10px 8px; text-align: left; border-bottom:1px solid #1d2740; }
    th{ color:#cfe1ff; text-transform: uppercase; letter-spacing: .6px; }
    td.rank{ width:56px; text-align:center; color:#7ec1ff }
    td.score{ font-weight:700; color:#fff }
    .pill{
      padding: 6px 10px; border-radius: 999px; background:#ffffff10; color:#dbe9ff; font-size: 12px;
    }
    .top1 .score{ color:#ffd54a }
    .top2 .score{ color:#c0e1ff }
    .top3 .score{ color:#ffc9a8 }

    .footerRow{ display:flex; justify-content:space-between; gap:8px; margin-top:14px }
    .ghost{ background:#ffffff14; color:#fff }
  </style>
</head>
<body>
  <!-- Telegram user badge (visible on home & leaderboard) -->
  <div id="userInfo" style="display:none;">
    <img id="userPhoto" alt="" />
    <span id="userName"></span>
  </div>

  <!-- Home -->
  <div id="homeScreen" class="screen">
    <div id="homeCard">
      <h1>üöÄ Space Rocket</h1>
      <div class="sub">Swipe left/right to control, avoid obstacles and collect <span style="color:#58d3ff">coins</span>!</div>
      <div class="row">
        <button id="startBtn" class="btn">Start Game</button>
        <button id="openBoardBtn" class="btn ghost">Leaderboard</button>
      </div>
    </div>
  </div>

  <!-- Game canvas -->
  <canvas id="gameCanvas"></canvas>

  <!-- Leaderboard -->
  <div id="leaderboardScreen" class="screen">
    <div id="boardCard">
      <div style="display:flex; align-items:center; justify-content:space-between; padding: 0 8px 8px;">
        <h2 style="margin:8px 0 0; font-size:22px">üèÜ Leaderboard (Total Coin)</h2> <!-- CHANGED HERE -->
        <span id="entriesMeta" class="pill">‚Äî</span>
      </div>
      <div style="overflow:auto; max-height: 60vh;">
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Name</th>
              <th>Coin (Total)</th> <!-- CHANGED HERE -->
              <!-- Removed "Last Played" header -->
            </tr>
          </thead>
          <tbody id="leaderboardBody"></tbody>
        </table>
      </div>
      <div class="footerRow">
        <button id="backHome" class="btn ghost">‚¨Ö Home</button>
        <button id="playAgain" class="btn">üîÑ Play Again</button>
      </div>
    </div>
  </div>

  <!-- Telegram SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <script type="module">
    /* ===== Firebase ===== */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
    import { getDatabase, ref, push, set, get, child } 
      from "https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCeD_9k4rfspxHa_T8KAZRhkPT_deFP-OA",
      authDomain: "ballonyup.firebaseapp.com",
      databaseURL: "https://ballonyup-default-rtdb.firebaseio.com",
      projectId: "ballonyup",
      storageBucket: "ballonyup.firebasestorage.app",
      messagingSenderId: "641854409703",
      appId: "1:641854409703:web:69933dac88bc7184874b42",
      measurementId: "G-94EH113TS5"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    /* ===== Telegram user ===== */
    const tg = window.Telegram?.WebApp;
    tg?.expand();

    const user = tg?.initDataUnsafe?.user;
    let currentUser = "guest";
    let photoUrl = "";
    if (user) {
      currentUser = user.username || [user.first_name, user.last_name].filter(Boolean).join(" ");
      photoUrl = user.photo_url || "";
    }
    const userInfo = document.getElementById("userInfo");
    const userNameEl = document.getElementById("userName");
    const userPhotoEl = document.getElementById("userPhoto");
    function showUserBadge(show){
      userInfo.style.display = show ? "flex" : "none";
    }
    userNameEl.textContent = currentUser;
    if (photoUrl) userPhotoEl.src = photoUrl;

    /* ===== Canvas / Game ===== */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    function resizeCanvas(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    // parallax stars
    const stars = [];
    for (let i=0;i<80;i++){
      stars.push({x:Math.random()*window.innerWidth, y:Math.random()*window.innerHeight, r:Math.random()*2+0.6, s:0.5+Math.random()*1.6});
    }
    function updateStars(){
      for (const s of stars){ s.y += s.s; if (s.y>window.innerHeight){ s.y=-3; s.x=Math.random()*window.innerWidth; } }
    }
    function drawStars(){
      ctx.fillStyle="#fff";
      for (const s of stars){ ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); }
    }

    // assets
    const rocketImg = new Image(); rocketImg.src = "assets/rocket.png";
    const obstacleImg = new Image(); obstacleImg.src = "assets/obstacle.png";
    const coinImg = new Image(); coinImg.src = "assets/coin.png";

    let running=false, score=0; // score now represents coins
    // Doubled rocket size, moved up, and added targetX for smooth movement
    // Added rotation properties to rocket
    let rocket = { 
      x: window.innerWidth/2-50, 
      y: window.innerHeight-200, 
      w: 100, 
      h: 100, 
      targetX: window.innerWidth/2-50, 
      speed: 0.15,
      rotation: 0, // Current rotation angle in radians
      targetRotation: 0, // Target rotation angle in radians
      rotationSpeed: 0.1 // How quickly the rocket rotates towards targetRotation
    };
    let obstacles=[], coins=[];
    let touchStartX=null;

    // Define rotation in radians for 10 degrees
    const ROTATION_ANGLE_RAD = 10 * Math.PI / 180;

    canvas.addEventListener("touchstart", e => { 
      touchStartX = e.touches[0].clientX; 
      // Immediately set targetX to current touch position for instant follow on touch start
      rocket.targetX = Math.max(0, Math.min(e.touches[0].clientX - rocket.w / 2, window.innerWidth - rocket.w));
    }, {passive:true});

    canvas.addEventListener("touchmove", e => {
      const currentTouchX = e.touches[0].clientX;
      const newTargetX = Math.max(0, Math.min(currentTouchX - rocket.w / 2, window.innerWidth - rocket.w));
      
      // Determine target rotation based on movement direction
      if (newTargetX < rocket.x) { // Moving left
        rocket.targetRotation = -ROTATION_ANGLE_RAD;
      } else if (newTargetX > rocket.x) { // Moving right
        rocket.targetRotation = ROTATION_ANGLE_RAD;
      } else { // Not moving horizontally
        rocket.targetRotation = 0;
      }

      rocket.targetX = newTargetX;
    }, {passive:true});

    canvas.addEventListener("touchend", e => {
      if (touchStartX==null) return;
      // Final position update on touch end
      const finalTouchX = e.changedTouches[0].clientX;
      rocket.targetX = Math.max(0, Math.min(finalTouchX - rocket.w / 2, window.innerWidth - rocket.w));
      
      // Reset target rotation to 0 when touch ends
      rocket.targetRotation = 0;
      touchStartX=null;
    });

    function spawnObstacle(){
      const size=72; // Doubled obstacle size
      // Define a specific padding for the obstacle's collision box
      const obstacleCollisionPadding = 15; // Adjust this value based on your obstacle image's transparent areas
      obstacles.push({
        x:Math.random()*(window.innerWidth-size), 
        y:-size, 
        w:size, 
        h:size, 
        vy:3, 
        rotation: 0, 
        rotationSpeed: (Math.random() - 0.5) * 0.05,
        collisionPadding: obstacleCollisionPadding // Add collision padding to obstacle object
      }); 
    }
    function spawnCoin(){
      const size=44; // Doubled coin size
      coins.push({
        x:Math.random()*(window.innerWidth-size), 
        y:-size, 
        w:size, 
        h:size, 
        vy:2,
        alpha: 1, // Initial opacity for animation
        collected: false // Flag for collection animation
      });
    }

    // Define a padding for collision detection to ignore transparent edges of the rocket
    const rocketCollisionPadding = 15; // Adjust this value as needed (e.g., 10-20px)

    function loop(t){
      if (!running) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // bg
      updateStars(); drawStars();

      // Smooth rocket movement
      rocket.x += (rocket.targetX - rocket.x) * rocket.speed;
      
      // Smooth rocket rotation
      rocket.rotation += (rocket.targetRotation - rocket.rotation) * rocket.rotationSpeed;

      // spawn
      if (Math.random()<0.008) spawnObstacle(); // Reduced obstacle spawn rate
      if (Math.random()<0.02) spawnCoin();

      // draw obstacles with rotation
      for (const o of obstacles){ 
        o.y+=o.vy; 
        o.rotation += o.rotationSpeed; // Update rotation
        if (obstacleImg.complete) {
          ctx.save(); // Save current canvas state
          ctx.translate(o.x + o.w / 2, o.y + o.h / 2); // Move origin to center of obstacle
          ctx.rotate(o.rotation); // Rotate
          ctx.drawImage(obstacleImg, -o.w / 2, -o.h / 2, o.w, o.h); // Draw image centered
          ctx.restore(); // Restore canvas state
        }
      }
      obstacles = obstacles.filter(o=>o.y<window.innerHeight+o.h+40); // Adjusted filter for larger obstacles

      // draw coins and handle collection animation
      for (const c of coins){ 
        if (!c.collected) {
          c.y+=c.vy; 
        } else {
          // If collected, fade out
          c.alpha -= 0.05; // Adjust fade speed
          if (c.alpha < 0) c.alpha = 0; // Ensure it doesn't go below 0
        }

        if (coinImg.complete && c.alpha > 0) {
          ctx.save();
          ctx.globalAlpha = c.alpha; // Apply current alpha
          ctx.drawImage(coinImg,c.x,c.y,c.w,c.h); 
          ctx.restore();
        }
      }
      // Filter out coins that are off-screen OR have fully faded out
      coins = coins.filter(c => c.y < window.innerHeight + c.h + 22 && c.alpha > 0); 

      // Draw rocket with rotation
      if (rocketImg.complete) {
        ctx.save(); // Save current canvas state
        ctx.translate(rocket.x + rocket.w / 2, rocket.y + rocket.h / 2); // Move origin to center of rocket
        ctx.rotate(rocket.rotation); // Rotate the rocket
        ctx.drawImage(rocketImg, -rocket.w / 2, -rocket.h / 2, rocket.w, rocket.h); // Draw image centered
        ctx.restore(); // Restore canvas state
      }

      // collisions
      for (const o of obstacles){ if (hit(rocket,o)){ return endGame(); } }
      for (let i=coins.length-1;i>=0;i--){ 
        // Only check collision for coins that haven't been collected yet
        if (!coins[i].collected && hit(rocket,coins[i])){ 
          score++; 
          coins[i].collected = true; // Mark as collected to start fade-out
          // coins.splice(i,1); // DO NOT splice immediately for animation
        } 
      }

      // HUD
      ctx.fillStyle="#eaf2ff"; 
      ctx.font="20px 'Press Start 2P'"; // Apply pixel font to HUD
      ctx.fillText("Coin: "+score, 12, 28); // Changed "Score:" to "Coin:"

      requestAnimationFrame(loop);
    }

    function hit(a,b){
      // Apply padding to shrink the collision box for the rocket (a)
      const aX = a.x + rocketCollisionPadding;
      const aY = a.y + rocketCollisionPadding;
      const aW = a.w - (rocketCollisionPadding * 2);
      const aH = a.h - (rocketCollisionPadding * 2);

      // Apply padding to shrink the collision box for the obstacle (b)
      // Use b.collisionPadding if available, otherwise default to 0 for coins (no padding)
      const bPadding = b.collisionPadding !== undefined ? b.collisionPadding : 0; 
      const bX = b.x + bPadding;
      const bY = b.y + bPadding;
      const bW = b.w - (bPadding * 2);
      const bH = b.h - (bPadding * 2);

      return aX < bX + bW && aX + aW > bX && aY < bY + bH && aY + aH > bY;
    }

    /* ===== Screens & Leaderboard ===== */
    const homeScreen = document.getElementById("homeScreen");
    const boardScreen = document.getElementById("leaderboardScreen");
    const startBtn = document.getElementById("startBtn");
    const openBoardBtn = document.getElementById("openBoardBtn");
    const backHome = document.getElementById("backHome");
    const playAgain = document.getElementById("playAgain");
    const tbody = document.getElementById("leaderboardBody");
    const entriesMeta = document.getElementById("entriesMeta");

    startBtn.addEventListener("click", ()=>{
      // Hide user badge when game starts
      showUserBadge(false);
      homeScreen.style.display="none";
      score=0; obstacles.length=0; coins.length=0;
      rocket.x = window.innerWidth/2-rocket.w/2; // Center rocket initially
      rocket.targetX = rocket.x; // Set targetX to current position
      rocket.y = window.innerHeight-200; // Adjusted rocket initial Y position
      rocket.rotation = 0; // Reset rocket rotation
      rocket.targetRotation = 0; // Reset target rotation
      running=true;
      requestAnimationFrame(loop);
    });

    openBoardBtn.addEventListener("click", async ()=>{
      await showLeaderboard();
      homeScreen.style.display="none";
      boardScreen.style.display="flex";
      // Show badge on leaderboard
      showUserBadge(true);
    });

    backHome.addEventListener("click", ()=>{
      boardScreen.style.display="none";
      homeScreen.style.display="flex";
      showUserBadge(true);
    });

    playAgain.addEventListener("click", ()=>{
      boardScreen.style.display="none";
      showUserBadge(false);
      startBtn.click();
    });

    async function endGame(){
      running=false;
      // save single session
      const scoresRef = ref(db, "scores");
      const newRef = push(scoresRef);
      await set(newRef, { username: currentUser, score, createdAt: new Date().toISOString() });
      // show aggregated leaderboard
      await showLeaderboard();
      boardScreen.style.display="flex";
      // Show badge again after game ends
      showUserBadge(true);
    }

    /**
     * Aggregated leaderboard (sum by username)
     * DB: scores/{id} -> { username, score, createdAt }
     * UI: one username per row, score = SUM(score)
     */
    async function showLeaderboard(){
      tbody.innerHTML = `<tr><td colspan="3" style="padding:16px; color:#cfe1ff">Loading...</td></tr>`; // Adjusted colspan
      const snapshot = await get(child(ref(db), "scores"));
      if (!snapshot.exists()){
        tbody.innerHTML = `<tr><td colspan="3" style="padding:16px; color:#cfe1ff">No coins yet.</td></tr>`; // Adjusted colspan
        entriesMeta.textContent = "0 players";
        return;
      }

      // aggregate by username
      const list = Object.values(snapshot.val()); // [{username, score, createdAt}, ...]
      const byUser = new Map();
      for (const row of list){
        const name = row.username || "guest";
        const s = Number(row.score)||0;
        const t = row.createdAt ? new Date(row.createdAt).getTime() : 0;
        if (!byUser.has(name)){
          byUser.set(name, { username:name, total:s, last:t });
        } else {
          const rec = byUser.get(name);
          rec.total += s;
          rec.last = Math.max(rec.last, t); // 'last' is still calculated but not displayed
        }
      }
      const aggregated = Array.from(byUser.values())
        .sort((a,b)=> b.total - a.total || b.last - a.last);

      // render
      tbody.innerHTML = "";
      aggregated.forEach((u, idx)=>{
        const tr = document.createElement("tr");
        if (idx===0) tr.classList.add("top1");
        else if (idx===1) tr.classList.add("top2");
        else if (idx===2) tr.classList.add("top3");
        tr.innerHTML = `
          <td class="rank">${idx+1}</td>
          <td>${u.username}</td>
          <td class="score">${u.total}</td>
          <!-- Removed "Last Played" data cell -->
        `;
        tbody.appendChild(tr);
      });
      entriesMeta.textContent = `${aggregated.length} players`;
    }

    // Show badge on initial screen
    showUserBadge(true);
  </script>
</body>
</html>
